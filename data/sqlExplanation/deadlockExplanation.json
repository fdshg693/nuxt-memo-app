[
    {
        "title": "デッドロック (DEADLOCK) の詳細解説",
        "description": "デッドロックは、複数のトランザクションが互いにリソースを待ち続けることで処理が進まなくなる状態です。適切なリソースの取得順序やロック戦略により回避できます。",
        "examples": [
            {
                "example": "-- 回避策: 一貫したリソース順序\nBEGIN;\nUPDATE table_a SET value = 1 WHERE id = 1;\nUPDATE table_b SET value = 2 WHERE id = 1;\nCOMMIT;",
                "explanation": "複数のテーブルを更新する際は、常に同じ順序（例：テーブル名のアルファベット順）でアクセスすることでデッドロックを防げます。",
                "DbName": "users"
            },
            {
                "example": "-- デッドロック発生例\n-- Transaction A: users → customers\n-- Transaction B: customers → users\nBEGIN;\nUPDATE users SET age = age + 1 WHERE id = 1;\nUPDATE customers SET age = age + 1 WHERE id = 2;\nCOMMIT;",
                "explanation": "2つのトランザクションが異なる順序で同じリソースにアクセスするとデッドロックが発生する可能性があります。",
                "DbName": "users"
            },
            {
                "example": "-- タイムアウト設定\nSET LOCK_TIMEOUT 5000;\nBEGIN;\nUPDATE products SET stock = stock - 1 WHERE id = 100;\nCOMMIT;",
                "explanation": "ロックタイムアウトを設定することで、デッドロック発生時の無限待機を防げます。",
                "DbName": "products"
            },
            {
                "example": "-- 小さなトランザクション\nBEGIN;\nUPDATE orders SET status = 'processing' WHERE id = 1;\nCOMMIT;\n-- 別のトランザクション\nBEGIN;\nUPDATE orders SET priority = 'high' WHERE id = 1;\nCOMMIT;",
                "explanation": "トランザクションを小さく保つことで、ロック時間を短縮しデッドロックの可能性を減らせます。",
                "DbName": "orders"
            },
            {
                "example": "-- インデックスの活用\nCREATE INDEX idx_user_age ON users(age);\nBEGIN;\nUPDATE users SET name = 'Updated' WHERE age = 25;\nCOMMIT;",
                "explanation": "適切なインデックスにより、より細かいロック粒度で済み、デッドロックリスクを軽減できます。",
                "DbName": "users"
            }
        ]
    }
]